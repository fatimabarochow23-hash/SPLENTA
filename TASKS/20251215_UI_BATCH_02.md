你是 JUCE/C++ GUI 工程师。我们做 SPLENTA GUI 移植的 Batch 02：只做“控件交互反馈层（LookAndFeel）”，不要改布局、不要改 APVTS 参数定义、不要改音频/业务逻辑。

【已知主题系统（必须严格使用这些字段名）】
Theme.h 中定义：
- enum class ThemeType { Bronze, Blue, Purple, Green, Pink };
- struct ThemePalette { juce::Colour accent, glow, bg950, panel900; 
  static ThemePalette getPaletteByIndex(int index); };

【Batch 02 功能要求（必须实现）】
1) 新增自定义 LookAndFeel：StealthLookAndFeel : public juce::LookAndFeel_V4
   - 内部持有 ThemePalette palette
   - 提供 setPalette(const ThemePalette&) 用于外部注入主题
   - active 判定统一为：
     active = slider.isMouseButtonDown() || slider.isMouseOverOrDragging(true)

2) 覆写 drawRotarySlider：
   - 画深色 knob body（使用 palette.panel900 / palette.bg950 风格），细边框
   - 画 indicator dot（圆点），位置必须用 cos/sin 计算
   - dot 默认灰色（建议 #A8A29E）
   - 当 active（hover/drag）时：
     - dot 变为 palette.accent
     - dot 产生 glow（类似 CSS boxShadow 0 0 5px），使用 juce::DropShadow 或径向渐变实现
   - 旋钮角度范围必须与 Web 一致：-145° 到 +145°
     （如果角度范围不是在 LookAndFeel 控制，请在创建 knob 的地方用 setRotaryParameters 对齐）

3) 覆写 drawLinearSlider（只需保证竖向 fader 交互一致）：
   - cap line（滑块帽的横线）永远使用 palette.accent
   - fill（填充条）在 active 时更亮/更实（accent alpha 更高），非 active 时更淡/弱化
   - active 时可给 cap 或 fill 加轻微 glow（建议做）

4) Editor 注入 LookAndFeel（最小改动）：
   - PluginEditor 持有 StealthLookAndFeel 实例并 setLookAndFeel(&lnf)
   - 析构 setLookAndFeel(nullptr)
   - 在“主题变化处理处”（例如 updateColors / updateThemeFromParam / timerCallback 中你能拿到 themeIndex 的地方）：
     ThemePalette p = ThemePalette::getPaletteByIndex(themeIndex);
     lnf.setPalette(p);
     repaint();

【输出要求（严格）】
A) 输出两个新文件的完整内容：
- Source/StealthLookAndFeel.h
- Source/StealthLookAndFeel.cpp

B) 不要输出大段与本批无关的代码；不要改布局；不要引入第三方库。
C) 对 PluginEditor 的改动：如果你不知道我工程里函数名，不要编造；请给“应插入到哪里”的最小片段与说明。

开始输出上述内容。
