# SPLENTA GUI Port Batch 05: Cartesian Topology & Panel Architecture

你是 JUCE/C++ 图形工程师。我们继续 SPLENTA 插件的 UI 移植工作。
**目标：**
1. 更新 Energy Topology (Visualizer) 的 "Pink" 主题算法，使其与 Web 版最新的 "3D Cartesian Trek" 一致。
2. 移植 Web 版的全局背景和模块面板（Panel）样式，移除所有旧的调试用边框，实现“幽暗工业风”视觉。

---

## 任务 1：更新 Pink 主题算法 (Cartesian Trek)

Web 版的 Pink 主题已从“Sakura”变更为“Cartesian Trek”（Lissajous 结 + 扫描仪效果）。
请找到项目中负责 `MobiusVisualizer` (或类似命名) 的组件，修改其渲染逻辑中对应 `Theme::Pink` 的部分。

**输入参考 (Web TSX 源码):**
```typescript
// 5. PINK: 3D CARTESIAN TREK
const drawCartesian = () => {
   const scale = Math.min(width, height) * 0.35;
   
   // 3D Projection Helper (Simple rotation matrix)
   const project = (x: number, y: number, z: number) => {
       const rotY = time * 0.3;
       const rotX = time * 0.2;
       // Rotate Y
       let tx = x * Math.cos(rotY) - z * Math.sin(rotY);
       let tz = x * Math.sin(rotY) + z * Math.cos(rotY);
       // Rotate X
       let ty = y * Math.cos(rotX) - tz * Math.sin(rotX);
       tz = y * Math.sin(rotX) + tz * Math.cos(rotX);
       // Perspective
       const fov = 1000;
       const scale2d = fov / (fov - tz); // Avoid divide by zero in C++
       return { x: cx + tx * scale2d, y: cy + ty * scale2d, scale: scale2d, z: tz };
   };

   // 1. Draw Curve (Lissajous Knot) - 使用 juce::Path
   // t from 0 to 2PI, samples = 150
   // x = scale * (sin(t) + 2 * sin(2*t)) / 2.5;
   // y = scale * (cos(t) - 2 * cos(2*t)) / 2.5;
   // z = scale * (-sin(3*t)) / 2;
   
   // 2. Draw "Traveler" & Grid
   // Traveler pos logic: same equations, t = (time * 0.5) % 2PI
   // Flash Logic: beatCycle = (time * 1.5) % 2; isFlash = beatCycle < 0.2;
   // Grid: Draw small dots around the traveler in 3D space.
};
```

**C++ 实现要求：**
- 使用 `juce::Path` 绘制那条曲线，而不是像 canvas 那样 moveTo/lineTo 每一帧都重绘所有像素（虽然 JUCE 重绘 Path 也是每帧，但请注意性能）。
- 实现简单的 3D 投影函数（Project）。
- 确保颜色透明度与 `intensity` 参数关联。

---

## 任务 2：全局背景与面板样式 (Panel Architecture)

Web 版不再使用显眼的边框。整个界面由 4 个半透明的“面板”组成。
请修改 `PluginEditor.cpp` 的 `paint` 方法。

**设计规范 (Web CSS 映射):**

1.  **全局背景 (Global Background):**
    - 颜色: `#0a0a0a` (接近纯黑)。
    - 容器背景: `#140c08` (Dark Bronze, `bg-bronze-950`)。
    
2.  **面板样式 (Panel Style):**
    - 你需要定义 4 个区域的 `juce::Rectangle<int>`（Input Detector, Enforcer Core, Energy Topology, Master Output）。
    - **背景**: `juce::Colours::white.withAlpha(0.03f)` (极淡的白色叠加)。
    - **Header (标题栏)**: 高度约 24-30px，颜色 `juce::Colours::black.withAlpha(0.2f)`，底部有一条 `1px` 的线 `white.withAlpha(0.05f)`。
    - **Corner Accents (角落装饰)**: 在面板的四个角绘制长度为 6px 的 L 型线条，颜色 `white.withAlpha(0.1f)`。
    - **文字**: 在 Header 左侧绘制标题（如 "ENFORCER CORE"），字体 `JetBrains Mono` (或默认等宽)，字号约 10-12px，全大写，颜色 `white.withAlpha(0.4f)`。
    - **状态点**: 标题旁画一个小圆点，如果是激活状态则亮起（使用 Theme Accent Color），否则暗淡。

3.  **移除旧代码:**
    - 删除所有 `g.setColour(juce::Colours::red); g.drawRect(...)` 这种调试用的边框代码。

**颜色参考 (Bronze Theme 默认):**
- Background: 0xFF140C08
- Accent: 0xFFFFB045

---

## 执行步骤
1. 打开 `MobiusVisualizerComponent.cpp` (或对应文件)，替换 Pink 模式为 Cartesian 逻辑。
2. 打开 `PluginEditor.h`，定义 4 个区域的 Bounds 布局常量（如果尚未定义）。
3. 打开 `PluginEditor.cpp`，在 `paint` 中：
   - 填充全屏背景。
   - 编写一个辅助函数 `drawPanel(Graphics& g, Rectangle<int> bounds, String title, bool isActive)` 来复用绘制逻辑。
   - 调用 4 次 `drawPanel` 绘制四个主要区域。
4. 编译并验证：
   - Pink 模式是否显示为扭曲的结（Knot）和扫描效果。
   - 界面是否变成了深色背景、无边框、带有 Header 条的工业风外观。
